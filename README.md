# Java Design Pattern

## 面向对象七大设计原则

* 单一职责原则

  一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。或者说，就一个类而言，应该仅有一个引起它变化地原因。

* 开闭原则

  软件实体应当对扩展开放，对修改关闭。抽象化是开闭原则的关键。

* 里氏替换原则

  所有引用基类的地方必须能透明地使用其子类。
  
* 依赖倒转原则

  高层模块不应该依赖于低层模块，他们都应该依赖于抽象。抽象不应该依赖于细节，而细节应该依赖于抽象。
  
  依赖倒转原则要求针对接口编程，不要针对实现编程。

* 接口隔离原则

  客户端不应该依赖于那些它不需要的接口。
  
  当一个接口太大时需要将它分割成一些更细小的接口，使用该接口的客户端仅需要知道与之相关的方法即可。

* 合成复用原则

  优先使用对象组合而不是通过继承来达到复用的目的。

* 迪米特法则

  每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。
  
  迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用。如果一个系统符合迪米特法则，那么其中的某一个模块发生修改时就会尽量少地影响其他模块，扩展会相对容易。
  
  保持松耦合，不要和“陌生人”说话。

## Java 3类23种设计模式

### 创建型模式(5种)

* 简单工厂模式

  简单工厂模式通过向工厂中的静态方法传递参数来获取对应的对象实例。

* 工厂方法模式

  工厂方法模式通过抽象类或者接口抽象出工厂类的共同方法，每个产品对应一个工厂子类（或工厂实现类）。

* 抽象工厂模式

  抽象工厂模式涉及到产品族和产品等级结构，通常一个产品族一个工厂。

* 建造者模式

  建造者模式关键思想在于一步一步构建一个复杂对象。

* 原型模式

  **定义**: 使用原型实例指定待创建的对象的类型，并通过复制这个原型来创建新的对象。

  原型模式指创建相同或相似的对象，实现关键在于复制，实现`clonable`接口的`clone()`方法，或者通过写入流中再写出实现深复制。**原型管理器**的实现也是一个要点。

* 单例模式

  **定义**:  确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。

  单例模式的四种写法：
  
  * 饿汉单例模式
  
  * 使用`synchronized`实现线程安全的懒汉单例模式
  
  * 使用双重锁机制和`volatile`实现线程安全的懒汉单例模式
  
  * 使用IoDH利用Java虚拟机实现线程安全的懒汉单例模式 


### 结构型模式(7种)

* 适配器模式

  **定义**: 将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。

  * 类适配器: 一般只存在继承和实现关系。
  
  * 对象适配器: 存在关联、继承或实现关系。
  
  * 默认适配器: 通过一个抽象类实现所有的目标方法，但实现并不写出具体的逻辑，而是使用空方法，再去继承这个抽象类进而只实现一部分目标方法。
  
  * 双向适配器: 目标类也可以是适配类。

* 桥接模式

  **定义**: 将抽象部分与它的实现部分解耦，使得两者都能够独立变化。
  
  实现桥接模式的关键在于将系统的两个独立的维度分开，并使用关联关系而不是继承关系来连接这两个独立的维度，从而降低类的个数和系统复杂度。

* 组合模式

  **定义**: 组合多个对象形成**树形结构**以表示具有部分—整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。
  
  组合模式的典型实现就是操作系统的**目录结构**：文件夹——文件。
  
  组合模式又可以分为**透明组合模式**和**安全组合模式**。

* 装饰模式

  **定义**: 动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更灵活的替代方案。
  
  一般而言，装饰模式可以多重装饰，即透明装饰模式。而半透明装饰模式只能实现一次装饰，但是可以单独调用增添的功能。

* 外观模式

  **定义**: 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
  
  外观模式的外观类相当于服务员，你作为客户端只需要跟服务员交互，具体的实现细节客户端不需要管。

* 享元模式

  **定义**: 运用共享技术有效地支持大量细粒度对象的复用。
  
  享元模式中通过提供享元池用于存储已经创建好的享元对象。通过享元模式创建的对象是同一对象，即使用`==`判断的结果为`true`，而在原型模式中创建的对象内容是一样的，但不是同一个对象。

  享元模式典型的实现就是`String`类。

* 代理模式

  **定义**: 给一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。
  
  代理模式跟适配器模式、装饰模式、外观模式都有些类似，代理类可以动态地增加一些功能，可以实现对真实对象的访问控制等等。
  
  代理模式分为很多种，如远程代理、保护代理、虚拟代理、缓冲代理、只能引用代理等等。远程代理的实现机制如RMI(Remote Method Invocation)。
  
  代理模式的分类还可以分为：
  
  * 静态代理
  
  * 动态代理(JDK动态代理、CGLIB动态代理等)，使用极为广泛，是许多框架中的极为重要的设计模式，如Spring。

### 行为型模式(11种)

  行为型模式关注系统中**对象之间的交互**，研究系统在运行时**对象之间的相互同行与协作**，进一步**明确对象的职责**。
  
* 职责链模式
  
  **定义**: 避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。
  
  职责链式模式还分为一下两种：
  
  * 纯的职责链模式：一个请求处理者要么处理请求，要么不处理请求，将其交给下家。
  
  * 不纯的职责链模式：一个请求处理者可以处理部分请求，然后将请求交给下家。（一个请求对象还可以最终不被任何请求处理者对象所接受并处理）
  
* 命令模式（又称动作模式或事务模式）

  **定义**: 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录日志，以及支持可撤销的操作。
  
  命令模式中，请求发送者将请求发送给命令对象，交由命令对象去处理，具体细节请求发送者无需了解；而命令对象又将请求转发给请求接收者，具体怎么实现命令对象也不管，交由请求接收者处理。
  
  这里与职责链是非常相似的，但是不同的是，命令对象的`execute()`方法只负责转发请求给请求接收者，而没有判断是否要自己处理，而且请求只转发**一次**就直接到了请求接收者。
  
  命令模式还有一下实现：
  
  * 命令队列
  
  * 记录请求日志
  
  * 实现撤销操作
  
  * 宏命令（组合模式与命令模式的结合）
  
* 解释器模式

  **定义**: 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
  
  解释器模式描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。当需要开发一个新的语言时可以考虑使用解释器模式。该模式使用频率较低。

* 迭代器模式

  **定义**: 提供一种方法顺序访问一个*聚合对象*中的各个元素，而又不用暴露该对象的内部表示。
  
  聚合对象拥有两个职责：一是存储数据，另一是遍历数据。从依赖性来看，前者是聚合对象的基本职责，后者既是可变化的，又是可分离的。因此使用迭代器模式将存储对象的职责和遍历对象的职责分开，使得系统更加符合单一职责原则。
  
  通过提供抽象聚合对象类和迭代器接口，使得系统扩展更加容易，符合开闭原则。
  
  迭代器模式还可使用内部类来设计，这样可以省去了具体聚合对象类与具体迭代器之间的双向关系。
  
  Java API中的集合框架中就用到了迭代器模式。
  
* **中介者模式**

  * 定义：定义一个对象来封装一系列对象的交互。中介者模式是对象之间不需要显式地相互引用，从而是其耦合松散，而且用户可以独立改变他们之间的交互。
  
  中介者模式是迪米特法则的一个典型应用。
  
  中介者模式的列子有很多，比如房产中介、房主、租房者三者之间的关系，QQ用户、QQ群这样的例子。将对象之间的关系由网状结构转变为以中介者为中心的星型结构。

* **备忘录模式**

  * 定义: 在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。

  * 角色介绍：

    * 原发器(Originator)：一个普通类，它通过创建一个备忘录来存储当前内部状态，也可以使用备忘录来恢复其内部状态，一般将系统中需要保存内部状态的类设计为原发器。

    * 备忘录(Memento): 备忘录用于存储原发起器的内部状态，根据原发器来决定保存那些内部状态。除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用。因此通常设计为包私有类型与原发器位于同一个包，或者设计成原发器的内部类。

    * 负责人(Caretaker): 负责人又称为管理类，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。
  
  备忘录模式一般用于提供撤销操作的系统的设计。

* **观察者模式**

  * 定义： 观察者模式定义对象中的一种一对多的依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新。

  * 角色介绍

    * 观察目标： 观察目标中定义了一个观察者集合，并提供增加和删除观察者的方法，同时定义了通知方法`notify()`。

    * 观察者： 观察者将对观察目标做出反应，观察者一般定义为接口，并声明`update()`方法。

  观察者模式用于描述对象之间的依赖关系，为实现多个对象之间的联动提供了一种解决方案。一个对象发生改变时，自动通知其他对象，其他对象将相应作出反应。
  
  JDK中的`java.util`包中提供了对观察者模式支持的类`Observable`和`Obsever`接口，在JDK中事件处理机制就是观察者模式的具体实现，还有MVC架构模式同样也是观察者模式的应用。

* **状态模式**

  * 定义： 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

  * 角色介绍

    * Context(环境类)： 环境类又称为上下文类，是拥有多种状态的对象。在环境类中维护一个抽象类State的实例，这个实例定义当前状态。环境类实际上是真正拥有状态的对象，只是将环境类中与状态有关的代码提取出来封装到专门的状态中。

    * State(抽象状态类)：用于定义一个接口或抽象类以封装与环境类的一个特定状态相关的行为，在抽象状态中声明了各种不同状态对应的方法。

    * ConcreteState(具体状态类)： 每一个具体状态类对应环境的一个具体状态。
  
  状态模式用于解决系统中复杂对象的状态转换一级不同状态下行为的封装问题。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。状态转换的职责既可以放在环境类中，也可以放在状态类中。

未完待续...